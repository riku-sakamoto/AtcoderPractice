# 001

- 二分探索
- 答えから決めていく貪欲法

# 002

- 全探索（ビットの操作）
// iのjビット目が0であるか
  i & (1 << j)
- カッコを見つける(累積的に)

# 003

木の直径は，最短距離計算を２回行う。
- 幅優先探索で最小距離を算出


# 004

初見OK
行と列で分解

# 005

桁DP
余りは行列の繰り返し演算にできる
行列累乗は繰り返し２乗法を用いる

小課題２まで

# 006

文字列問題は前から貪欲法
アルファベットは有限
ある文字が何番目に登場するかのマップを持っておくと検索が早い


# 007

lower_boundの定義

# 008

初見OK
DP

# 010

初見OK
和の分割

# 012

初見OK
UnionFind


# 20

std::powは内部が浮動小数点で実装されているので，誤差がでる

## 26

dfsによる木構造の探索

## 28

二次元いもす法

## 32

next_permutation

binary_searchの前はsortするのを忘れない。

## 34

尺取り法

## 36

マンハッタン距離は４５度回転でチェビシェフ距離になる。端点のみに注目すればよい。

## 37

セグメント木（RMQ）を使って高速化
queryの区間には注意


## 43

01BFS
方向によって最小距離が変わる

## 44 

初見で解けなかった。。Orz..
繰り返しのような連続的な変化はメモ化する。毎回当てはめなくてもいい。


## 51

半分に分けて全探索

## 55

combinationは単純なFORループでいい

## 56

初見OKだが，重要
DP復元


## 58 

周期性に注目

## 60

LIS: 最小増加部分列
両側から

## 66

期待値は分解できる


## 67

進数変換は０の時に気を付ける

## 68

グループ分けは単純にUnionFind
クエリの先読み


## 70 

OK
マンハッタン距離の総和の最小は中央値


## 72

バックトラック


## 73

木上のDP

## 75

約数問題を正しく解けるか

## 76

OK しゃくとり法

ただし，円環を２倍にできるとさらに楽

